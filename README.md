# ABC Book Backend

## Setup instructions
1. Clone repository:
```
git clone git@github.com:isaacl16/abc-book-backend.git
```
2. Install the packages.

```
npm install
```
3. Create a .env and fill in the following. 
```
MONGODB_URI = ""
MONGODB_DBNAME = ""
JWT_SIGNING_KEY = "NTNv7j0TuYARvmNMmWXo6fKvM4o6nv/aUi9ryX38ZH+L1bkrnD1ObOQ8JAUmHCBq7Iy7otZcyAagBLHVKvvYaIpmMuxmARQ97jUVG16Jkpkp1wXOPsrF9zwew6TpczyHkHgX5EuLg2MeBuiT/qJACs1J0apruOOJCg/gOtkjB4c="
```
4. Start the server
```
npm run start
```
To run in development mode, use the command `npm run dev`

## Assumptions
1. Data validation is done on the frontend
2. Last borrower is always set to the most recent or current borrower
3. Editor is allowed to access User Management but can only view the users and cannot add, remove and update users
4. Log in service is already implemented using JWT
    * In parts of the code implementation, we will assume that the token has been validated


## Additional information
To test the APIs on from the backed service, we will be using a self-generated JWT which is used for the sole purpose of authorization when making calling upon an API. We can use the following [link]("https://jwt.io/") to generate a JWT

The payload should contain the following:

* _id: (User _id generated by Mongodb)
* name: 
* role: (admin/editor/member)

The Verify Signature requires a secret key. Use the JWT_SIGNING_KEY in the .env for this. (You should never expose your secret key)

Ensure to include the token in request headers. 
```
Authorization: Bearer <JWT>
```



## Project Structure
The project is structured in the following way:
* abc-book-backend
    * `controllers`: Contains controller functions that handles logic for different routes
    * `db`: Contains the code for connectivity with MongoDB
    * `middleware/`: Contains middleware for handling authentication
    * `models/`: Contains the Mongoose models for the User, Book and User objects
    * `node_modules`: Contains downloaded packages
    * `routes/`: Contains the Express.js routes for handling the CRUD APIs
    * `utils`: Contains utility functions
    * `index.js`: The entry point of the application, where the server is started and the routes are imported.
    * `.env`: Contains environment configuration settings

## API Design

A reference to the APIs has been uploaded to the project. Click [here](https://github.com/isaacl16/abc-book-backend/blob/master/ABC-Book.postman_collection.json) to view.

### Users
* `GET /users`: Retrieves a list of all users (including pagination)
* `GET /users/:_id`: Retrieves a specific user by id
* `POST /users`: Creates a new user
* `PUT /users/:_id`: Updates a specific user by id
* `DELETE /users`: Deletes multiple users
* `DELETE /users/:_id`: Deletes a specific user by id

### Books
* `GET /books`: Retrieves a list of all books (including pagination)
* `GET /books/:_id`: Retrieves a specific book by id
* `POST /books`: Creates a new book
* `PUT /books/:_id`: Updates a specific book by id
* `DELETE /books`: Deletes multiple books
* `DELETE /books/:_id`: Deletes a specific book by id

### Borrowing and Returning
* `PATCH /books/borrowBook`: Borrow a book by id
* `PATCH /books/returnBook`: Return a book by id
* `PATCH /books/:_id/borrowBook` Borrow multiple books
* `PATCH /books/:_id/returnBook` Return multiple books

### Requests
* `GET /requests`: Retrieves a list of all request (including pagination)
* `GET /requests/:_id`: Retrieves a specific request by id
* `POST /requests`: Creates a new request
* `PATCH /requests/:_id/approve`: Approves a specific request that is not created by the user and performs add, update or remove on users
* `PATCH /requests/:_id/reject`: Rejects a specific request that is not created by the user

## Code implementation

For my choice of library for interacting with MongoDB, I selected Mongoose because of my familiarity with it and its benefits. Mongoose allows for easy and efficient interactions with the database, reducing the amount of boilerplate code required, and providing a consistent and simplified API for querying the database. It also includes powerful validation and middleware system, which ensures that only valid data is saved to the database.

A package called dotenv is used to securely load environment variables from the .env file, which is particularly useful for storing sensitive information such as the database connection strings and JWT signing keys.

The APIs are designed to follow the principles of Representational State Transfer (REST), making them easy to use and understand. This design pattern is widely adopted in the industry, providing a consistent and predictable way of interacting with the server.

Authentication middleware is also implemented to check for valid tokens (assumed to be done), and to verify that the role in the token has been given authorization to perform or call the API. This ensures that only authenticated and authorized users can access the API.

In addition to the standard CRUD operations on User and Book objects, the project also includes the features for borrowing and returning books. This feature is implemented using PATCH HTTP requests, which allows for partial updates of the resource, making it more efficient and appropriate for this use case.

Finally, for the implementation of the maker checker rule, a request system is implemented. The system is designed using a request model, which allows admins to submit requests for adding, removing, and updating users. The model includes fields for the user's information, the action to be taken, the request's status, the name of the admin owner of the request, and the name of the admin who has taken action on the request. To ensure oversight and accountability, requests are reviewed and acted upon by admins who are not the owner of the request. This ensures that multiple parties review the requests, and any actions taken are done so with proper authorization. This provides an additional layer of security and ensures that only authorized changes are made to the system.

## Scalability

Adoptation of the stateless programming paradigm where the state of the system is not stored in memory but instead in an external data storage like MongoDB. This approach allows for easy scalability as new instances can be added without the need to share the state, enabling horizontal scaling to handle increased traffic and meet the demands of a growing user base. Additionally, this approach enhances the flexibility and maintainability of the system by reducing dependencies between different instances, making it simpler to update and modify individual parts of the system independently.

In order to enhance the scalability of the database, sharding and indexing are implemented as an optimization technique. Sharding is the process of horizontally partitioning data across multiple servers, allowing for the distribution of data and better management of large sets of data. This improves the scalability of the database, as new servers can be added to handle increased traffic and larger data sets. Indexing is a technique that improves the performance of the database by creating a data structure that allows for faster retrieval of data. By indexing the relevant fields in the collections, it allows for faster searching and sorting of data which can improve the overall performance of the database and allows the system to scale better. Together, these techniques allow the database to handle a large number of requests and a large amount of data, improving its scalability and performance.





    