# ABC Book Backend

## Setup instructions
1. Clone repository:
```
git clone git@github.com:isaacl16/abc-book-backend.git
```
2. Install the packages.

```
npm install
```
3. Create a .env and fill in the following. 
```
MONGODB_URI = ""
MONGODB_DBNAME = ""
JWT_SIGNING_KEY = "NTNv7j0TuYARvmNMmWXo6fKvM4o6nv/aUi9ryX38ZH+L1bkrnD1ObOQ8JAUmHCBq7Iy7otZcyAagBLHVKvvYaIpmMuxmARQ97jUVG16Jkpkp1wXOPsrF9zwew6TpczyHkHgX5EuLg2MeBuiT/qJACs1J0apruOOJCg/gOtkjB4c="
```
4. Start the server
```
npm run start
```
To run in development mode, use the command `npm run dev`

## Assumptions
1. Data validation is done on the frontend
2. Last borrower is always set to the most recent or current borrower
3. Editor is allowed to access User Management but can only view the users and cannot add, remove and update users
4. Log in service is already implemented using JWT
    * In parts of the code implementation, we will assume that the token has been validated with the database


## Additional information
To test the APIs on from the backed service, we will be using a self-generated JWT which is used for the sole purpose of authorization when making calling upon an API. We can use the following [link]("https://jwt.io/") to generate ourselves a token.

The payload should contain the following:

* _id: (User _id generated by Mongodb)
* name: 
* role: (admin/editor/member)

The Verify Signature requires a secret key. Use the JWT_SIGNING_KEY in the .env for this. (You should never expose your secret key)

Ensure to include the token in request headers. It should look something like this
```
{
    Authorization: Bearer <JWT>
}
```


## Project Structure
The project is structured in the following way:
* abc-book-backend
    * `controllers`: Contains controller functions that handles logic for different routes
    * `db`: Contains the code for connectivity with MongoDB
    * `middleware/`: Contains middleware for handling authentication
    * `models/`: Contains the Mongoose models for the User, Book and User objects
    * `node_modules`: Contains downloaded packages
    * `routes/`: Contains the Express.js routes for handling the CRUD
    * `utils`: Contains utility functions
    * `index.js`: The entry point of the application, where the server is started and the routes are imported.
    * `.env`: Contains environment configuration settings

## API Design

### Users
* `GET /users`: Retrieves a list of all users (including pagination)
* `GET /users/:_id`: Retrieves a specific user by id
* `POST /users`: Creates a new user
* `PUT /users/:_id`: Updates a specific user by id
* `DELETE /users`: Deletes multiple users
* `DELETE /users/:_id`: Deletes a specific user by id

### Books
* `GET /books`: Retrieves a list of all books (including pagination)
* `GET /books/:_id`: Retrieves a specific book by id
* `POST /books`: Creates a new book
* `PUT /books/:_id`: Updates a specific book by id
* `DELETE /books`: Deletes multiple books
* `DELETE /books/:_id`: Deletes a specific book by id

### Borrowing and Returning
* `PATCH /books/borrowBook`: Borrow a book by id
* `PATCH /books/returnBook`: Return a book by id
* `PATCH /books/:_id/borrowBook` Borrow multiple books
* `PATCH /books/:_id/returnBook` Return multiple books

### Requests
* `GET /requests`: Retrieves a list of all request (including pagination)
* `GET /requests/:_id`: Retrieves a specific request by id
* `POST /requests`: Creates a new request
* `PATCH /requests/:_id/approve`: Approves a specific request that is not created by the user and performs add, update or remove on users
* `PATCH /requests/:_id/reject`: Rejects a specific request that is not created by the user

## Code implementation

For my choice of library for interacting with MongoDB, I selected Mongoose because of my familiarity with it and its benefits. Mongoose allows for easy and efficient interactions with the database, reducing the amount of boilerplate code required, and providing a consistent and simplified API for querying the database. It also includes powerful validation and middleware system, which ensures that only valid data is saved to the database.

A package called dotenv is used to securely load environment variables from the .env file, which is particularly useful for storing sensitive information such as the database connection strings and JWT signing keys.

The APIs are designed to follow the principles of Representational State Transfer (REST), making them easy to use and understand. This design pattern is widely adopted in the industry, providing a consistent and predictable way of interacting with the server.

Authentication middleware is also implemented to check for valid tokens (assumed to be done), and to verify that the role in the token has been given authorization to perform or call the API. This ensures that only authenticated and authorized users can access the API.

```
const verifyAdmin = (req, res, next) => {
    const token = req.headers.authorization.split(' ')[1];
    if (!token) {
        return res.status(401).json({ message: 'Unauthorized access' });
    }
    try {
        const decoded = decodeToken(token);
        //pretend we have already verified with database if token is valid
        if (decoded.role !== 'admin') {
            return res.status(401).json({ message: 'Unauthorized access' });
        }
    } catch (err) {
        return res.status(401).json({ message: 'Unauthorized access' });
    }
    next();
};
```

In addition to the standard CRUD operations on User and Book objects, the project also includes the features for borrowing and returning books. This feature is implemented using PATCH HTTP requests, which allows for partial updates of the resource, making it more efficient and appropriate for this use case.

Finally, for the implementation of the maker checker rule, a request system is implemented. The system is designed using a request model, which allows admins to submit requests for adding, removing, and updating users. The model includes fields for the user's information, the action to be taken, the request's status, the owner of the request, and the name of the admin who has taken action on the request. To ensure oversight and accountability, requests are reviewed and acted upon by admins who are not the owner of the request. This ensures that multiple parties review the requests, and any actions taken are done so with proper authorization. This provides an additional layer of security and ensures that only authorized changes are made to the system.

## Scalability
The overall structure of project designed with the idea of modularity kept in mind. This helps when it comes to scalability and future changes such as converting it to a microservice architecture where code has already been written such that they are not too dependant on each other.

aside from that Asynchronous programming is used to handle large number of requests. This way, the application can handle requests at the same time without waiting for a response from each request. 

Database optimization with the use sharding and indexing will allow for better performances and scalability of the database 

Aside from the code level, we can add in the addition of load balances and auto-scaling groups which allows for addition of more servers to handle increased traffic

Elasticsearch can also be integrated to help with full text searches especially while searching for book titles in mongodb




    